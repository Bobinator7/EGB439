#include <iostream>
#include <regex>
#include <list>

using namespace std;

int main(int argc, char **argv) {
  
  string str;

  regex HSV("HSV\\[([0-9]+) ([0-9]+) ([0-9]+)\\]");
  regex BGR("BGR\\[([0-9]+) ([0-9]+) ([0-9]+)\\]");
  smatch sm_hsv, sm_bgr;

  //TODO: typedef or c++11 equivalent for readability
  list<tuple<tuple<int,int,int>,tuple<int,int,int>,tuple<int,float,float>>> beacon_blue;
  list<tuple<tuple<int,int,int>,tuple<int,int,int>,tuple<int,float,float>>> beacon_green;
  list<tuple<tuple<int,int,int>,tuple<int,int,int>,tuple<int,float,float>>> beacon_red;
  list<tuple<tuple<int,int,int>,tuple<int,int,int>,tuple<int,float,float>>> floor_green;

  while (getline(cin,str)) {
    if (str[0] == '-') {
      int flag = 0;		//TODO: replace int with enum for readability
      while (getline(cin,str) && !str.empty()) {

	//cout << str << endl;
        if (str.find("beacon red") != string::npos) {
          //cout << "red values coming up!" << endl;
	  flag = 1;
	} else if (str.find("beacon green") != string::npos) {
          //cout << "green values coming up!" << endl;
	  flag = 2;
	} else if (str.find("beacon blue") != string::npos) {
	  //cout << "blue values coming up!" << endl;
	  flag = 3;
	} else if (str.find("floor green") != string::npos) {
	  //cout << "green floor values coming up!" << endl;
	  flag = 4;
	} else {
          //cout << "parse HSV and BGR values" << endl;
          if (regex_search(str,sm_hsv,HSV) && regex_search(str,sm_bgr,BGR)) {
	    int h = stoi(sm_hsv[1].str());
	    int s = stoi(sm_hsv[2].str());
	    int v = stoi(sm_hsv[3].str());
	    //cout << h << s << v << endl;
	    int b = stoi(sm_bgr[1].str());
	    int g = stoi(sm_bgr[2].str());
	    int r = stoi(sm_bgr[3].str());
	    //cout << b << g << r << endl;
	    if (flag == 1) {
	      beacon_red.push_back(make_tuple(make_tuple(h,s,v),make_tuple(b,g,r),make_tuple(0,0,0)));
	    } else if (flag == 2) {
	      beacon_green.push_back(make_tuple(make_tuple(h,s,v),make_tuple(b,g,r),make_tuple(0,0,0)));
	    } else if (flag == 3) {
	      beacon_blue.push_back(make_tuple(make_tuple(h,s,v),make_tuple(b,g,r),make_tuple(0,0,0)));
	    } else if (flag == 4) {
	      floor_green.push_back(make_tuple(make_tuple(h,s,v),make_tuple(b,g,r),make_tuple(0,0,0)));
	    }

	  } else {
	    cout << "Invalid line format! Skip line.." << endl;
	    continue;
	  }
	}

      }
    }
  }
  
  //cout << "calculate luminance and chromaticity in form (y,cr,cg)"
  for (auto it : beacon_red) {
    //cout << get<0>(get<0>(it)) << endl;
    int y = get<0>(get<1>(it)) + get<1>(get<1>(it)) + get<2>(get<1>(it));
    float cr = (float)get<2>(get<1>(it)) / (float)y;
    float cg = (float)get<1>(get<1>(it)) / (float)y;
    get<2>(it) = make_tuple(y,cr,cg);
    cout << y << ", " << cr << ", " << cg << endl;
  }
  cout << "-" << endl;

  for (auto it : beacon_green) {
    //cout << get<0>(get<0>(it)) << endl;
    int y = get<0>(get<1>(it)) + get<1>(get<1>(it)) + get<2>(get<1>(it));
    float cr = (float)get<2>(get<1>(it)) / (float)y;
    float cg = (float)get<1>(get<1>(it)) / (float)y;
    get<2>(it) = make_tuple(y,cr,cg);
    cout << y << ", " << cr << ", " << cg << endl;
  }
  cout << "-" << endl;

  for (auto it : beacon_blue) {
    //cout << get<0>(get<0>(it)) << endl;
    int y = get<0>(get<1>(it)) + get<1>(get<1>(it)) + get<2>(get<1>(it));
    float cr = (float)get<2>(get<1>(it)) / (float)y;
    float cg = (float)get<1>(get<1>(it)) / (float)y;
    get<2>(it) = make_tuple(y,cr,cg);
    cout << y << ", " << cr << ", " << cg << endl;
  }
  cout << "-" << endl;

  for (auto it : floor_green) {
    //cout << get<0>(get<0>(it)) << endl;
    int y = get<0>(get<1>(it)) + get<1>(get<1>(it)) + get<2>(get<1>(it));
    float cr = (float)get<2>(get<1>(it)) / (float)y;
    float cg = (float)get<1>(get<1>(it)) / (float)y;
    get<2>(it) = make_tuple(y,cr,cg);
    cout << y << ", " << cr << ", " << cg << endl;
  }

  //process color information 
  //e.g.: normalized colorspace, boundaries, histogram equalization
  //autogenerated color boundaries?

  return 0;
}
